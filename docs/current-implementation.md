# Текущая реализация проекта IRIS

## Общая информация

IRIS (Information Systems) — это многомодульный проект на языке Kotlin, представляющий собой компилятор и виртуальную машину для языка программирования на русском языке. Проект разработан с использованием Gradle и Kotlin 2.2.21, требует JDK 21.

## Архитектура проекта

Проект состоит из 6 основных модулей:

### 1. **core** — Ядро системы
Содержит общие типы данных и структуры, используемые во всех модулях:

#### AST (Абстрактное синтаксическое дерево)
- **Expr.kt** — Выражения:
  - `IntLiteral` — целочисленные литералы
  - `BoolLiteral` — булевы литералы
  - `Var` — переменные
  - `BinaryExpr` — бинарные операции
  - `UnaryExpr` — унарные операции
  - `Call` — вызов функций
  - `FieldAccess` — доступ к полям структур
  - `New` — выделение памяти в куче

- **Stmt.kt** — Операторы:
  - `Block` — блок операторов
  - `VarDecl` — объявление переменных
  - `If` — условное ветвление
  - `While` — цикл while
  - `Return` — возврат из функции
  - `Break` — выход из цикла
  - `Continue` — продолжение цикла
  - `PrintInt` — вывод целого числа (для демонстрации)

- **TypeRef.kt** — Ссылки на типы данных
- **Operator.kt** — Операторы языка
- **Decl.kt** — Объявления (функции, структуры)
- **Program.kt** — Программа как список операторов

#### Байткод
- **Bytecode.kt** — Структуры байткода:
  - `BytecodeProgram` — скомпилированная программа
  - `Instr` — инструкция байткода
  - `OpCode` — коды операций:
    - `PUSH_I64` — поместить 64-битное целое в стек
    - `PRINT_I64` — вывести 64-битное целое из стека
    - `HALT` — остановка выполнения

#### Диагностика
- **Diagnostic.kt** — Система сообщений об ошибках
- **Span.kt** — Позиция в исходном коде

### 2. **parser** — Парсер и лексер
Модуль для разбора исходного кода:

#### Лексер
- **Lexer.kt** — Токенизация исходного кода:
  - Поддержка комментариев (`//`)
  - Распознавание ключевых слов на русском языке:
    - `целч` — тип int
    - `бул` — тип bool
    - `если`, `иначе` — условные операторы
    - `пока` — цикл while
    - `нч`, `кц` — начало и конец блока (замена `{` и `}`)
    - `функция`, `процедура` — объявление функций
    - `структ` — объявление структур
    - `вернуть` — return
    - `выйти` — break
    - `продолжить` — continue
    - `новый` — выделение памяти
    - `печать` — вывод
    - `правда`, `ложь` — булевы значения
  - Распознавание операторов: `+`, `-`, `*`, `/`, `%`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `!`
  - Распознавание идентификаторов и числовых литералов

- **Token.kt** — Токены
- **TokenKind.kt** — Типы токенов
- **LexResult.kt** — Результат лексического анализа

- **LexerTest.kt** — Тесты лексера:
  - Объявление переменных
  - Присваивание значений
  - Арифметические операции
  - Условные блоки if-else
  - Циклы while
  - Вывод

#### Парсер
- **Parser.kt** — Упрощенный парсер для демонстрации:
  - В данный момент реализован простой построчный парсер
  - Поддерживает команды вида `print <число>`
  - Создан как заглушка для дальнейшей разработки полноценного парсера

- **ParseResult.kt** — Результат синтаксического анализа

### 3. **compiler** — Компилятор
Модуль для компиляции AST в байткод:

- **Compiler.kt** — Компилятор AST → байткод:
  - В данный момент реализована компиляция оператора `PrintInt`
  - Генерирует инструкции:
    - `PUSH_I64` для загрузки значения
    - `PRINT_I64` для вывода
    - `HALT` для остановки программы
  - Поддержка диагностики ошибок компиляции

- **CompileResult.kt** — Результат компиляции

### 4. **vm** — Виртуальная машина
Модуль интерпретации байткода:

- **VirtualMachine.kt** — Стековая виртуальная машина:
  - Однопоточная архитектура
  - Стек на основе `ArrayDeque<Long>`
  - Интерпретация байткода:
    - `PUSH_I64` — помещает значение в стек
    - `PRINT_I64` — извлекает и выводит значение из стека
    - `HALT` — завершает выполнение с кодом 0
  - Поддержка пользовательского вывода (можно перенаправить stdout)

- **VmResult.kt** — Результат выполнения
- **VirtualMachineTest.kt** — Тесты виртуальной машины

### 5. **jit** — JIT-компилятор (асинхронный)
Модуль для Just-In-Time компиляции:

- **AsyncJit.kt** — Асинхронный JIT-компилятор:
  - Протокол асинхронной компиляции
  - VM остается однопоточной
  - Компиляция выполняется в фоновом режиме (Dispatchers.Default)
  - Использует корутины Kotlin (kotlinx.coroutines)
  - Результат публикуется атомарно
  - VM может продолжать интерпретацию до готовности нативного кода
  - **Примечание**: В данный момент реализован только протокол, без генерации реального нативного кода
  - Имитирует компиляцию с задержкой 10мс

### 6. **cli** — Интерфейс командной строки
Модуль для запуска программ:

- **Main.kt** — Точка входа приложения:
  - Чтение файлов с исходным кодом
  - Запуск полного конвейера: парсинг → компиляция → выполнение
  - Демонстрация работы JIT-компилятора
  - Вывод диагностических сообщений
  - Поддержка двух режимов:
    - Без аргументов: выполняет демо-программу (`print 1\nprint 2\nprint 3\n`)
    - С аргументом: выполняет указанный файл

## Примеры использования

### Запуск демо-программы
```bash
./gradlew :cli:run
```

Вывод:
```
1
[jit] not ready yet (expected for tiny programs)
2
3
```

### Запуск файла с кодом
```bash
./gradlew :cli:run --args="examples/hello.is"
```

Вывод:
```
42
[jit] not ready yet (expected for tiny programs)
7
42
7
```

## Текущее состояние

### Что полностью реализовано:
1. ✅ **Структура проекта** — многомодульная архитектура с четким разделением ответственности
2. ✅ **Лексер** — полная токенизация с поддержкой всех ключевых слов языка
3. ✅ **AST** — определены все необходимые узлы для выражений, операторов и деклараций
4. ✅ **Простой парсер** — построчный парсер для команды `print`
5. ✅ **Компилятор** — компиляция простых программ с `print` в байткод
6. ✅ **Виртуальная машина** — интерпретация байткода со стековой архитектурой
7. ✅ **Протокол JIT** — асинхронная архитектура JIT-компиляции
8. ✅ **CLI** — командный интерфейс для запуска программ
9. ✅ **Система тестирования** — юнит-тесты для лексера и VM
10. ✅ **Диагностика** — система сообщений об ошибках с позицией в коде

### Что частично реализовано:
- ⚠️ **Парсер** — текущая реализация поддерживает только `print <число>`, требуется полный парсер для всех конструкций языка
- ⚠️ **Компилятор** — поддерживает только оператор `PrintInt`, нужно добавить остальные операторы
- ⚠️ **VM** — реализовано только 3 инструкции, требуется больше для полноценной работы
- ⚠️ **JIT** — реализован только протокол, без реальной генерации нативного кода

### Что еще нужно реализовать:
- ❌ **Полный парсер** — разбор всех конструкций языка согласно спецификации
- ❌ **Расширенная компиляция** — поддержка всех операторов, выражений, функций, структур
- ❌ **Расширенный набор инструкций VM** — арифметика, управление потоком, вызовы функций, работа с памятью
- ❌ **Система типов** — проверка типов на этапе компиляции
- ❌ **Управление памятью** — работа с кучей, указателями, массивами
- ❌ **Функции и процедуры** — вызовы, параметры, возвращаемые значения
- ❌ **Структуры** — определение, создание экземпляров, доступ к полям
- ❌ **Реальный JIT** — генерация нативного кода

## Спецификация языка

Подробная спецификация синтаксиса языка IRIS находится в файле `docs/language-spec.md`.

## Технологии

- **Язык**: Kotlin 2.2.21
- **Сборка**: Gradle 9.0.0
- **JDK**: 21
- **Зависимости**:
  - `kotlinx-coroutines-core` — для асинхронного JIT
  - `kotlin-test` — для юнит-тестов

## Статистика кода

- **Всего файлов**: 23 Kotlin-файла
- **Строк кода**: ~700 строк
- **Модулей**: 6
- **Тестов**: 7 (6 для лексера, 1 для VM)

## Примечания

Проект находится в стадии активной разработки. Реализована базовая инфраструктура и минимальный набор функциональности для демонстрации полного цикла: исходный код → токены → AST → байткод → выполнение.

Лексер готов к работе с полным синтаксисом языка, но парсер, компилятор и VM требуют расширения для поддержки всех возможностей, описанных в спецификации.
